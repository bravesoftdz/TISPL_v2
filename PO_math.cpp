//---------------------------------------------------------------------------
#pragma hdrstop
#include "PO_math.h"
#include "math.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
//---------------------------------------------------------------------------
//pøepoèet souvisejících hodnot vyplývajících ze zmìny CT
void TPO_math::input_CT()
{
	if(RD_locked)DD=RD*CT;//pro pøípad RD zamèeno
	else RD=DD/CT;				//pro pøípad DD zamèeno

	//vyladit
	K=CT/TT;//výpoèet kapacity
	Mezera();
}
//---------------------------------------------------------------------------
//pøepoèet souvisejících  hodnot vyplývajících ze zmìny RD
void TPO_math::input_RD()
{
	if(CT_locked)DD=RD*CT;//pro pøípad CT zamèeno
	else CT=DD/RD;				//pro pøípad DD zamèeno
}
//---------------------------------------------------------------------------
//pøepoèet  souvisejících hodnot vyplývajících ze zmìny DD
void TPO_math::input_DD()
{
	if(RD_locked)CT=DD/RD;//pro pøípad RD zamèeno
	else RD=DD/CT;				//pro pøípad CT zamèeno
}
//---------------------------------------------------------------------------
//pøepoèet  souvisejících hodnot vyplývajících ze zmìny K
void TPO_math::input_K()
{

}
//---------------------------------------------------------------------------
//pøepoèet  souvisejících hodnot vyplývajících ze zmìny M
void TPO_math::input_M()
{

}
//---------------------------------------------------------------------------
//vrátí velikost mezery
double TPO_math::Mezera()
{
	if(mV==1)//poèet mezer o jednu menší než poèet vozíkù
	{
		M=(DD-K*dV)/(K-1);
	}
	//else

}
//---------------------------------------------------------------------------
//vrátí poèet pozic
double TPO_math::Pozice()
{
	 double P=floor(K);//celoèíselná kapacita
	 double DVM=(dV+M)*(K-P);//délka neceloèíselné vozíko mezery v kabinì
	 if(DVM>dV)P++;//navýší o celý vozík
	 else P+=dV*DVM;//navýší o èást vozíku
	 return P;
}
//---------------------------------------------------------------------------
